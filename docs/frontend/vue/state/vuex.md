# Vuex Áä∂ÊÄÅÁÆ°ÁêÜÊ∑±Â∫¶Ëß£Êûê

VuexÊòØVue.jsÁöÑÂÆòÊñπÁä∂ÊÄÅÁÆ°ÁêÜÂ∫ìÔºåÈááÁî®ÈõÜ‰∏≠ÂºèÂ≠òÂÇ®ÁÆ°ÁêÜÂ∫îÁî®ÁöÑÊâÄÊúâÁªÑ‰ª∂Áä∂ÊÄÅÔºåÂπ∂‰ª•Áõ∏Â∫îÁöÑËßÑÂàô‰øùËØÅÁä∂ÊÄÅ‰ª•ÂèØÈ¢ÑÊµãÁöÑÊñπÂºèÂèëÁîüÂèòÂåñ„ÄÇ

## üéØ VuexÊ†∏ÂøÉÊ¶ÇÂøµ

```mermaid
graph TB
    A[Vue Components] --> B[Actions]
    B --> C[Mutations]
    C --> D[State]
    D --> A
    
    E[Backend API] --> B
    F[Devtools] --> C
    
    subgraph "Vuex Store"
        D
        C
        B
        G[Getters]
    end
    
    D --> G
    G --> A
```

### Ê†∏ÂøÉÁªÑÊàêÈÉ®ÂàÜ

- **State**ÔºöÂçï‰∏ÄÁä∂ÊÄÅÊ†ëÔºåÂ≠òÂÇ®Â∫îÁî®ÁöÑÊâÄÊúâÁä∂ÊÄÅ
- **Getters**Ôºö‰ªéstateÊ¥æÁîüÁöÑÁä∂ÊÄÅÔºåÁ±ª‰ººËÆ°ÁÆóÂ±ûÊÄß
- **Mutations**ÔºöÂêåÊ≠•‰øÆÊîπstateÁöÑÂîØ‰∏ÄÊñπÂºè
- **Actions**ÔºöÂºÇÊ≠•Êìç‰ΩúÔºåÊèê‰∫§mutations
- **Modules**ÔºöÊ®°ÂùóÂåñÁÆ°ÁêÜÔºåÈÅøÂÖçÂçï‰∏ÄÁä∂ÊÄÅÊ†ëËøá‰∫éÂ∫ûÂ§ß

## üèóÔ∏è VuexÊ∫êÁ†ÅÂÆûÁé∞ÂéüÁêÜ

### 1. StoreÁ±ªÊ†∏ÂøÉÂÆûÁé∞

```javascript
class Store {
  constructor(options = {}) {
    const {
      plugins = [],
      strict = false
    } = options

    // ÂÜÖÈÉ®Áä∂ÊÄÅ
    this._committing = false
    this._actions = Object.create(null)
    this._actionSubscribers = []
    this._mutations = Object.create(null)
    this._wrappedGetters = Object.create(null)
    this._modules = new ModuleCollection(options)
    this._modulesNamespaceMap = Object.create(null)
    this._subscribers = []
    this._watcherVM = new Vue()
    this._makeLocalGettersCache = Object.create(null)

    // ÁªëÂÆöcommitÂíådispatchÁöÑthisÊåáÂêë
    const store = this
    const { dispatch, commit } = this
    this.dispatch = function boundDispatch(type, payload) {
      return dispatch.call(store, type, payload)
    }
    this.commit = function boundCommit(type, payload) {
      return commit.call(store, type, payload)
    }

    // ‰∏•Ê†ºÊ®°Âºè
    this.strict = strict

    const state = this._modules.root.state

    // ÂàùÂßãÂåñÊ†πÊ®°ÂùóÔºåÈÄíÂΩíÊ≥®ÂÜåÊâÄÊúâÂ≠êÊ®°Âùó
    installModule(this, state, [], this._modules.root)

    // ÂàùÂßãÂåñstore vmÔºå‰ΩøstateÂíågettersÂìçÂ∫îÂºè
    resetStoreVM(this, state)

    // Â∫îÁî®Êèí‰ª∂
    plugins.forEach(plugin => plugin(this))
  }

  get state() {
    return this._vm._data.$$state
  }

  set state(v) {
    if (process.env.NODE_ENV !== 'production') {
      assert(false, `use store.replaceState() to explicit replace store state.`)
    }
  }

  commit(_type, _payload, _options) {
    // Áªü‰∏ÄÊ†ºÂºè
    const { type, payload, options } = unifyObjectStyle(_type, _payload, _options)

    const mutation = { type, payload }
    const entry = this._mutations[type]
    
    if (!entry) {
      if (process.env.NODE_ENV !== 'production') {
        console.error(`[vuex] unknown mutation type: ${type}`)
      }
      return
    }

    // ÊâßË°åmutation
    this._withCommit(() => {
      entry.forEach(function commitIterator(handler) {
        handler(payload)
      })
    })

    // ÈÄöÁü•ËÆ¢ÈòÖËÄÖ
    this._subscribers
      .slice()
      .forEach(sub => sub(mutation, this.state))

    if (process.env.NODE_ENV !== 'production' && options && options.silent) {
      console.warn(
        `[vuex] mutation type: ${type}. Silent option has been removed. ` +
        'Use the filter functionality in the vue-devtools'
      )
    }
  }

  dispatch(_type, _payload) {
    // Áªü‰∏ÄÊ†ºÂºè
    const { type, payload } = unifyObjectStyle(_type, _payload)

    const action = { type, payload }
    const entry = this._actions[type]
    
    if (!entry) {
      if (process.env.NODE_ENV !== 'production') {
        console.error(`[vuex] unknown action type: ${type}`)
      }
      return
    }

    try {
      this._actionSubscribers
        .slice()
        .filter(sub => sub.before)
        .forEach(sub => sub.before(action, this.state))
    } catch (e) {
      if (process.env.NODE_ENV !== 'production') {
        console.warn(`[vuex] error in before action subscribers: `)
        console.error(e)
      }
    }

    const result = entry.length > 1
      ? Promise.all(entry.map(handler => handler(payload)))
      : entry[0](payload)

    return new Promise((resolve, reject) => {
      result.then(res => {
        try {
          this._actionSubscribers
            .filter(sub => sub.after)
            .forEach(sub => sub.after(action, this.state))
        } catch (e) {
          if (process.env.NODE_ENV !== 'production') {
            console.warn(`[vuex] error in after action subscribers: `)
            console.error(e)
          }
        }
        resolve(res)
      }, error => {
        try {
          this._actionSubscribers
            .filter(sub => sub.error)
            .forEach(sub => sub.error(action, this.state, error))
        } catch (e) {
          if (process.env.NODE_ENV !== 'production') {
            console.warn(`[vuex] error in error action subscribers: `)
            console.error(e)
          }
        }
        reject(error)
      })
    })
  }

  // Á°Æ‰øùÂè™ËÉΩÈÄöËøámutation‰øÆÊîπstate
  _withCommit(fn) {
    const committing = this._committing
    this._committing = true
    fn()
    this._committing = committing
  }
}
```

### 2. ÂìçÂ∫îÂºèÂÆûÁé∞

```javascript
function resetStoreVM(store, state, hot) {
  const oldVm = store._vm

  // ÁªëÂÆöstoreÁöÑgetters
  store.getters = {}
  // ÈáçÁΩÆÊú¨Âú∞gettersÁºìÂ≠ò
  store._makeLocalGettersCache = Object.create(null)
  const wrappedGetters = store._wrappedGetters
  const computed = {}
  
  forEachValue(wrappedGetters, (fn, key) => {
    // ‰ΩøÁî®computedÊù•Âà©Áî®ÂÖ∂ÁºìÂ≠òÁâπÊÄß
    computed[key] = partial(fn, store)
    Object.defineProperty(store.getters, key, {
      get: () => store._vm[key],
      enumerable: true
    })
  })

  // ‰ΩøÁî®VueÂÆû‰æãÊù•‰øùÂ≠òstateÂíågetters
  const silent = Vue.config.silent
  Vue.config.silent = true
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed
  })
  Vue.config.silent = silent

  // ÂêØÁî®‰∏•Ê†ºÊ®°Âºè
  if (store.strict) {
    enableStrictMode(store)
  }

  if (oldVm) {
    if (hot) {
      // ÁÉ≠ÈáçËΩΩÊó∂‰øùÊåÅÁé∞ÊúâÁä∂ÊÄÅ
      store._withCommit(() => {
        oldVm._data.$$state = null
      })
    }
    Vue.nextTick(() => oldVm.$destroy())
  }
}

function enableStrictMode(store) {
  store._vm.$watch(function () { return this._data.$$state }, () => {
    if (process.env.NODE_ENV !== 'production') {
      assert(store._committing, `do not mutate vuex store state outside mutation handlers.`)
    }
  }, { deep: true, sync: true })
}
```

### 3. Ê®°ÂùóÁ≥ªÁªüÂÆûÁé∞

```javascript
class ModuleCollection {
  constructor(rawRootModule) {
    // Ê≥®ÂÜåÊ†πÊ®°Âùó
    this.register([], rawRootModule, false)
  }

  get(path) {
    return path.reduce((module, key) => {
      return module.getChild(key)
    }, this.root)
  }

  getNamespace(path) {
    let module = this.root
    return path.reduce((namespace, key) => {
      module = module.getChild(key)
      return namespace + (module.namespaced ? key + '/' : '')
    }, '')
  }

  register(path, rawModule, runtime = true) {
    if (process.env.NODE_ENV !== 'production') {
      assertRawModule(path, rawModule)
    }

    const newModule = new Module(rawModule, runtime)
    if (path.length === 0) {
      this.root = newModule
    } else {
      const parent = this.get(path.slice(0, -1))
      parent.addChild(path[path.length - 1], newModule)
    }

    // Ê≥®ÂÜåÂµåÂ•óÊ®°Âùó
    if (rawModule.modules) {
      forEachValue(rawModule.modules, (rawChildModule, key) => {
        this.register(path.concat(key), rawChildModule, runtime)
      })
    }
  }
}

class Module {
  constructor(rawModule, runtime) {
    this.runtime = runtime
    this._children = Object.create(null)
    this._rawModule = rawModule
    const rawState = rawModule.state

    this.state = (typeof rawState === 'function' ? rawState() : rawState) || {}
  }

  get namespaced() {
    return !!this._rawModule.namespaced
  }

  addChild(key, module) {
    this._children[key] = module
  }

  removeChild(key) {
    delete this._children[key]
  }

  getChild(key) {
    return this._children[key]
  }

  hasChild(key) {
    return key in this._children
  }

  update(rawModule) {
    this._rawModule.namespaced = rawModule.namespaced
    if (rawModule.actions) {
      this._rawModule.actions = rawModule.actions
    }
    if (rawModule.mutations) {
      this._rawModule.mutations = rawModule.mutations
    }
    if (rawModule.getters) {
      this._rawModule.getters = rawModule.getters
    }
  }

  forEachChild(fn) {
    forEachValue(this._children, fn)
  }

  forEachGetter(fn) {
    if (this._rawModule.getters) {
      forEachValue(this._rawModule.getters, fn)
    }
  }

  forEachAction(fn) {
    if (this._rawModule.actions) {
      forEachValue(this._rawModule.actions, fn)
    }
  }

  forEachMutation(fn) {
    if (this._rawModule.mutations) {
      forEachValue(this._rawModule.mutations, fn)
    }
  }
}
```

## üîß È´òÁ∫ßÁî®Ê≥ï‰∏éÊúÄ‰Ω≥ÂÆûË∑µ

### 1. Ê®°ÂùóÂåñËÆæËÆ°

```javascript
// store/modules/user.js
const state = {
  profile: null,
  permissions: [],
  preferences: {}
}

const getters = {
  isLoggedIn: state => !!state.profile,
  hasPermission: state => permission => {
    return state.permissions.includes(permission)
  },
  fullName: state => {
    return state.profile ? `${state.profile.firstName} ${state.profile.lastName}` : ''
  }
}

const mutations = {
  SET_PROFILE(state, profile) {
    state.profile = profile
  },
  SET_PERMISSIONS(state, permissions) {
    state.permissions = permissions
  },
  UPDATE_PREFERENCES(state, preferences) {
    state.preferences = { ...state.preferences, ...preferences }
  },
  CLEAR_USER_DATA(state) {
    state.profile = null
    state.permissions = []
    state.preferences = {}
  }
}

const actions = {
  async login({ commit, dispatch }, credentials) {
    try {
      const response = await api.login(credentials)
      const { user, token, permissions } = response.data
      
      // Â≠òÂÇ®token
      localStorage.setItem('token', token)
      
      // Êõ¥Êñ∞Áä∂ÊÄÅ
      commit('SET_PROFILE', user)
      commit('SET_PERMISSIONS', permissions)
      
      // Ëé∑ÂèñÁî®Êà∑ÂÅèÂ•ΩËÆæÁΩÆ
      await dispatch('fetchPreferences')
      
      return user
    } catch (error) {
      throw error
    }
  },

  async logout({ commit }) {
    try {
      await api.logout()
    } finally {
      localStorage.removeItem('token')
      commit('CLEAR_USER_DATA')
    }
  },

  async fetchPreferences({ commit, state }) {
    if (!state.profile) return
    
    try {
      const response = await api.getUserPreferences(state.profile.id)
      commit('UPDATE_PREFERENCES', response.data)
    } catch (error) {
      console.error('Failed to fetch user preferences:', error)
    }
  }
}

export default {
  namespaced: true,
  state,
  getters,
  mutations,
  actions
}
```

### 2. Êèí‰ª∂Á≥ªÁªü

```javascript
// ÊåÅ‰πÖÂåñÊèí‰ª∂
const persistencePlugin = store => {
  // ÂàùÂßãÂåñÊó∂‰ªélocalStorageÊÅ¢Â§çÁä∂ÊÄÅ
  const savedState = localStorage.getItem('vuex-state')
  if (savedState) {
    store.replaceState(JSON.parse(savedState))
  }

  // ÁõëÂê¨mutationÔºå‰øùÂ≠òÁä∂ÊÄÅÂà∞localStorage
  store.subscribe((mutation, state) => {
    // Âè™‰øùÂ≠òÁâπÂÆöÊ®°ÂùóÁöÑÁä∂ÊÄÅ
    const stateToSave = {
      user: state.user,
      settings: state.settings
    }
    localStorage.setItem('vuex-state', JSON.stringify(stateToSave))
  })
}

// Êó•ÂøóÊèí‰ª∂
const loggerPlugin = store => {
  store.subscribe((mutation, state) => {
    console.group(`Mutation: ${mutation.type}`)
    console.log('Payload:', mutation.payload)
    console.log('State after:', state)
    console.groupEnd()
  })

  store.subscribeAction((action, state) => {
    console.group(`Action: ${action.type}`)
    console.log('Payload:', action.payload)
    console.log('State before:', state)
    console.groupEnd()
  })
}

// ‰ΩøÁî®Êèí‰ª∂
const store = new Vuex.Store({
  // ...
  plugins: [persistencePlugin, loggerPlugin]
})
```

### 3. ‰∏•Ê†ºÊ®°Âºè‰∏éÂºÄÂèëÂ∑•ÂÖ∑

```javascript
const store = new Vuex.Store({
  // ÂºÄÂèëÁéØÂ¢ÉÂêØÁî®‰∏•Ê†ºÊ®°Âºè
  strict: process.env.NODE_ENV !== 'production',
  
  // ÂºÄÂèëÂ∑•ÂÖ∑ÊîØÊåÅ
  devtools: process.env.NODE_ENV !== 'production',
  
  plugins: process.env.NODE_ENV !== 'production' 
    ? [createLogger()] 
    : []
})
```

## üéØ ÊÄßËÉΩ‰ºòÂåñÊäÄÂ∑ß

### 1. ÂêàÁêÜ‰ΩøÁî®getters

```javascript
// ‚ùå ÈÅøÂÖçÂú®getters‰∏≠ËøõË°åÊòÇË¥µËÆ°ÁÆó
const getters = {
  expensiveGetter: state => {
    // ÊØèÊ¨°ËÆøÈóÆÈÉΩ‰ºöÈáçÊñ∞ËÆ°ÁÆó
    return state.items.map(item => {
      // ÊòÇË¥µÁöÑËÆ°ÁÆó
      return processItem(item)
    })
  }
}

// ‚úÖ ‰ΩøÁî®ÁºìÂ≠ò‰ºòÂåñ
const getters = {
  expensiveGetter: state => {
    // Âà©Áî®VueÁöÑËÆ°ÁÆóÂ±ûÊÄßÁºìÂ≠ò
    return state.processedItems
  }
}

const mutations = {
  SET_ITEMS(state, items) {
    state.items = items
    // È¢ÑÂ§ÑÁêÜÊï∞ÊçÆ
    state.processedItems = items.map(processItem)
  }
}
```

### 2. ÈÅøÂÖçÈ¢ëÁπÅÁöÑÁä∂ÊÄÅÂèòÊõ¥

```javascript
// ‚ùå È¢ëÁπÅÁöÑÂçï‰∏™mutation
actions: {
  updateMultipleFields({ commit }, data) {
    commit('SET_FIELD_A', data.a)
    commit('SET_FIELD_B', data.b)
    commit('SET_FIELD_C', data.c)
  }
}

// ‚úÖ ÊâπÈáèÊõ¥Êñ∞
mutations: {
  UPDATE_MULTIPLE_FIELDS(state, data) {
    Object.assign(state, data)
  }
}

actions: {
  updateMultipleFields({ commit }, data) {
    commit('UPDATE_MULTIPLE_FIELDS', data)
  }
}
```

### 3. Ê®°ÂùóÊáíÂä†ËΩΩ

```javascript
// Âä®ÊÄÅÊ≥®ÂÜåÊ®°Âùó
const store = new Vuex.Store({
  modules: {
    // Ê†∏ÂøÉÊ®°Âùó
    user: userModule
  }
})

// Ë∑ØÁî±Á∫ßÂà´ÁöÑÊ®°ÂùóÊáíÂä†ËΩΩ
router.beforeEach(async (to, from, next) => {
  if (to.matched.some(record => record.meta.requiresAuth)) {
    if (!store.hasModule('admin')) {
      const adminModule = await import('./store/modules/admin')
      store.registerModule('admin', adminModule.default)
    }
  }
  next()
})
```

VuexÈÄöËøáÂÖ∂‰∏•Ê†ºÁöÑÁä∂ÊÄÅÁÆ°ÁêÜÊ®°ÂºèÂíåÂº∫Â§ßÁöÑÂºÄÂèëÂ∑•ÂÖ∑ÊîØÊåÅÔºå‰∏∫Â§ßÂûãVueÂ∫îÁî®Êèê‰æõ‰∫ÜÂèØÈ¢ÑÊµãÁöÑÁä∂ÊÄÅÁÆ°ÁêÜËß£ÂÜ≥ÊñπÊ°à„ÄÇ
